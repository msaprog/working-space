/* eslint-disable no-param-reassign */

// Реализуйте и экспортируйте по умолчанию функцию, которая принимает объект
// и позволяет обращаться только к "публичным" свойствам и методам.
// При попытке прочитать или перезаписать приватное или несуществующее свойство
// должно выбрасываться исключение.

// BEGIN (write your solution here)

// Ответ для себя нашел - я не вызвал оригинальный "публичный метод",
// оригинального класса в set и ошибочно, считал что все присваиваемые
// значения должны выбрасывать ошибку, хотя это касалось только приватных свойств.

// Вы правы, ошибку нужно выбрасывать только при попытке перезаписать несуществующее
// или приватное свойство, остальные нужно перезаписывать

// В том случае, если значением свойства является функция, нам нужно привязать эту
// функцию к контексту исходного объекта при помощи bind(), а затем вернуть.
// Это позволит вызывать метод в контексте исходного объекта, а не объекта прокси

// Обратите внимание, что на вход в ловушку get приходит имя свойства,
// к которому идет обращение. Это строка, и она не может быть функцией.
// Функцией может быть значение этого свойства в исходном объекте.
// То есть сначала нужно получить значение этого свойства и уже его проверить,
// является ли оно функцией.

// Владислав, когда есть "матрёшка" объектов, то вызов метода на верхнем объекте
// приводит к обращению объекту верхнего уровня.И если там не было getName(),
// то оно упадёт с ошибкой.Поэтому до того, как отдать свойство наружу,
// надо через typeof проверить - это метод или нет
// и отдать его либо со связыванием, либо без.

export default (obj) => {
  const validateProperty = (target, prop) => {
    if (!(prop in target)) {
      throw new Error(`Property "${prop}" doesn't exist`);
    }
    if (prop.startsWith('_')) {
      throw new Error(`Property "${prop}" is protected`);
    }
  };

  const secret = new Proxy(obj, {
    set(target, prop, value) {
      validateProperty(target, prop);
      target[prop] = value;
      return true;
    },
    get(target, prop) {
      validateProperty(target, prop);
      if (typeof (target[prop]) === 'function') {
        return target[prop].bind(obj);
      }
      return target[prop];
    },
  });
  return secret;
};
// END
